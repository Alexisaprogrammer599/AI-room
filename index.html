<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hall Simulation</title>
  <style>
    :root{
      --win-blue:#0b2a8f;
      --win-gray:#c0c0c0;
      --win-dark:#3a3a3a;
      --win-black:#0b0b0b;
      --win-green:#21c24a;
      --win-red:#b31919;
      --text:#eaeaea;
    }
    html,body{height:100%; margin:0; background:#111; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    .wrap{height:100%; display:flex; align-items:center; justify-content:center; padding:16px;}
    .window{
      width:min(980px, 96vw);
      height:min(640px, 92vh);
      background:var(--win-gray);
      border:2px solid #fff;
      box-shadow: 0 0 0 2px #000, 10px 12px 0 rgba(0,0,0,.35);
      display:flex;
      flex-direction:column;
      border-radius:2px;
      overflow:hidden;
    }
    .titlebar{
      background:linear-gradient(90deg, var(--win-blue), #2c5bff);
      color:#fff;
      padding:6px 8px;
      font-weight:600;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      user-select:none;
    }
    .titlebar .left{display:flex; gap:8px; align-items:center}
    .icon{
      width:14px;height:14px;background:#fff; opacity:.9;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.35);
    }
    .controls{display:flex; gap:6px; align-items:center}
    .btn{
      width:16px;height:14px;background:#d9d9d9;
      box-shadow: inset -1px -1px 0 #7a7a7a, inset 1px 1px 0 #fff, 0 0 0 1px #000;
    }
    .content{
      flex:1;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:10px;
      padding:10px;
      min-height:0;
    }
    .pane{
      background:#f6f6f6;
      box-shadow: inset 0 0 0 2px #808080, inset 0 0 0 3px #fff;
      position:relative;
      min-height:0;
      overflow:hidden;
    }
    canvas{display:block; width:100%; height:100%; image-rendering: pixelated;}
    .hud{
      position:absolute; inset:10px 10px auto 10px;
      color:#fff;
      font: 12px/1.25 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      text-shadow: 0 1px 0 #000;
      background:rgba(0,0,0,.35);
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.18);
      max-width: 70%;
    }
    .side{
      display:flex;
      flex-direction:column;
      min-height:0;
      gap:10px;
    }
    .card{
      background:#efefef;
      box-shadow: inset 0 0 0 2px #808080, inset 0 0 0 3px #fff;
      padding:10px;
    }
    .card h3{margin:0 0 6px 0; font-size:13px}
    .mono{font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#111;}
    .log{
      background:#000;
      color:var(--text);
      padding:10px;
      height:220px;
      overflow:auto;
      border:2px solid #000;
      box-shadow: inset 0 0 0 2px #2a2a2a, inset 0 0 0 3px #000;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    .row{display:flex; gap:8px; margin-top:8px}
    input[type="text"]{
      flex:1;
      padding:8px;
      border:2px solid #000;
      box-shadow: inset 0 0 0 2px #808080, inset 0 0 0 3px #fff;
      font: 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .action{
      padding:8px 10px;
      background:#d9d9d9;
      border:2px solid #000;
      box-shadow: inset -1px -1px 0 #7a7a7a, inset 1px 1px 0 #fff;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
    }
    .hint{
      margin-top:8px;
      color:#222;
      font-size:12px;
    }
    .hint code{background:#ddd; padding:1px 4px; border:1px solid #aaa}
    a{color:#003bce; text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>
<body>
<div class="wrap">
  <div class="window" role="application" aria-label="Simulation window">
    <div class="titlebar">
      <div class="left"><div class="icon" aria-hidden="true"></div><div>Hall of Tortured Souls (Sim)</div></div>
      <div class="controls" aria-hidden="true"><div class="btn"></div><div class="btn"></div><div class="btn"></div></div>
    </div>

    <div class="content">
      <div class="pane" id="viewPane">
        <canvas id="cv"></canvas>
        <div class="hud" id="hud">
          WASD / Arrows: move • Q/E: turn • Shift: run • Enter: focus input • T: text-only page
        </div>
      </div>

      <div class="side">
        <div class="card">
          <h3>Prompt Console</h3>
          <div class="log" id="log" aria-label="Log"></div>
          <div class="row">
            <input id="inp" type="text" placeholder="Type a question… (e.g., 'what is outside')" autocomplete="off" />
            <button class="action" id="send">SEND</button>
          </div>
          <div class="hint mono">
            Door = bright green frame. Approach it to “exit.”<br/>
            Press <code>T</code> to open <code>text.html</code>.
          </div>
        </div>

        <div class="card mono">
          <h3>Simulation Notes</h3>
          <div>
            This is a tiny raycast corridor “room/door” demo with a retro palette (blue columns, red walls, green trims).<br/>
            Edit <code>script</code> near the bottom to change map layout or responses.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas setup (pixelated raycast) =====
  const canvas = document.getElementById('cv');
  const pane = document.getElementById('viewPane');
  const ctx = canvas.getContext('2d', { alpha: false });

  function resize() {
    const r = pane.getBoundingClientRect();
    // internal resolution for chunky pixels:
    const scale = 2; // tweak for more/less pixelation
    canvas.width  = Math.max(320, Math.floor(r.width  / scale));
    canvas.height = Math.max(240, Math.floor(r.height / scale));
  }
  new ResizeObserver(resize).observe(pane);
  resize();

  // ===== World map =====
  // 0 empty, 1 red wall, 2 blue pillar, 3 door frame, 4 "void" (dark)
  const MAP_W = 16, MAP_H = 16;
  const map = [
    "1111111111111111",
    "1000000000000001",
    "1020000011110001",
    "1000000010010001",
    "1000111110010001",
    "1000100000010001",
    "1000102222010001",
    "1000102002010001",
    "1000102222010001",
    "1000100000010001",
    "1000111110010001",
    "1000000010010001",
    "1000000011110331",
    "1000000000000001",
    "1000000000000001",
    "1111111111111111",
  ].join("");

  const cell = (x,y) => {
    if (x<0||y<0||x>=MAP_W||y>=MAP_H) return 1;
    return map[y*MAP_W + x] | 0;
  };

  // ===== Player =====
  const player = {
    x: 2.5, y: 2.5,
    a: 0, // angle
    fov: Math.PI/3,
    speed: 2.0,
    turn: 2.4
  };

  // ===== Retro palette =====
  const PAL = {
    sky:  [18,18,22],
    floor:[128,110,20],      // mustard floor
    ceil: [30,180,60],       // green trim effect (we'll use as ceiling accent)
    red:  [179,25,25],
    blue: [20,40,140],
    door: [40,220,90],
    dark: [10,10,10],
    grid: [210,210,210],
  };

  function putPixel(buf, i, r,g,b) {
    buf[i]=r; buf[i+1]=g; buf[i+2]=b; buf[i+3]=255;
  }

  // Simple "texture" noise for chunky look
  function shade(base, dist, stripe=0) {
    const k = Math.max(0.18, 1 / (1 + dist*dist*0.18));
    const s = stripe ? (0.85 + 0.15*Math.sin(stripe)) : 1;
    return base.map((v,idx)=> Math.max(0, Math.min(255, Math.floor(v*k*s))));
  }

  // Raycast
  function castRay(a) {
    const sin = Math.sin(a), cos = Math.cos(a);
    let dist = 0;
    let hit = 0;
    let hitX = 0, hitY = 0;
    let side = 0;

    // DDA
    let x = Math.floor(player.x);
    let y = Math.floor(player.y);

    const dx = cos === 0 ? 1e30 : Math.abs(1 / cos);
    const dy = sin === 0 ? 1e30 : Math.abs(1 / sin);

    let stepX, stepY;
    let sideDistX, sideDistY;

    if (cos < 0) { stepX = -1; sideDistX = (player.x - x) * dx; }
    else         { stepX =  1; sideDistX = (x + 1.0 - player.x) * dx; }

    if (sin < 0) { stepY = -1; sideDistY = (player.y - y) * dy; }
    else         { stepY =  1; sideDistY = (y + 1.0 - player.y) * dy; }

    for (let i=0; i<128; i++) {
      if (sideDistX < sideDistY) {
        sideDistX += dx; x += stepX; side = 0;
      } else {
        sideDistY += dy; y += stepY; side = 1;
      }
      hit = cell(x,y);
      if (hit !== 0) {
        // distance to wall
        dist = side === 0 ? (x - player.x + (1-stepX)/2) / cos
                          : (y - player.y + (1-stepY)/2) / sin;
        hitX = x; hitY = y;
        break;
      }
    }
    return { dist: Math.abs(dist), hit, hitX, hitY, side };
  }

  function render() {
    const w = canvas.width, h = canvas.height;
    const img = ctx.getImageData(0,0,w,h);
    const buf = img.data;

    // Paint base sky/floor
    for (let y=0; y<h; y++) {
      const t = y / h;
      const isFloor = y > h/2;
      const base = isFloor ? PAL.floor : PAL.sky;
      const alt  = isFloor ? PAL.floor : PAL.sky;
      const row = y*w*4;
      for (let x=0; x<w; x++) {
        const i = row + x*4;
        putPixel(buf, i, base[0], base[1], base[2]);
      }
      // thin green "ceiling trim" band near top quarter for vibe
      if (!isFloor && y > h*0.18 && y < h*0.22) {
        const row2 = y*w*4;
        for (let x=0; x<w; x++) {
          const i = row2 + x*4;
          putPixel(buf, i, PAL.ceil[0], PAL.ceil[1], PAL.ceil[2]);
        }
      }
    }

    // Raycast columns
    for (let x=0; x<w; x++) {
      const camX = (2*x/w - 1);
      const rayA = player.a + Math.atan(camX * Math.tan(player.fov/2));
      const r = castRay(rayA);

      const dist = r.dist * Math.cos(rayA - player.a); // fish-eye correction
      const lineH = Math.min(h, Math.floor(h / (dist + 0.0001)));
      const y0 = Math.floor((h - lineH)/2);
      const y1 = y0 + lineH;

      // Choose material color
      let base = PAL.red;
      if (r.hit === 2) base = PAL.blue;
      if (r.hit === 3) base = PAL.door;
      if (r.hit === 4) base = PAL.dark;

      // Make red walls "grid-ish"
      const stripe = (r.side ? 1 : 0) + (x*0.22);
      const col = shade(base, dist, stripe);

      // Darken one side for depth
      if (r.side === 1) {
        col[0] = (col[0]*0.72)|0;
        col[1] = (col[1]*0.72)|0;
        col[2] = (col[2]*0.72)|0;
      }

      for (let y=y0; y<y1; y++) {
        if (y<0||y>=h) continue;
        const i = (y*w + x)*4;

        // Add crude "pixel texture" by modulating every few pixels
        const tex = ((x>>1) + (y>>1)) & 3;
        const k = (tex===0) ? 0.85 : (tex===1 ? 0.95 : (tex===2 ? 1.05 : 1.0));
        putPixel(buf, i, (col[0]*k)|0, (col[1]*k)|0, (col[2]*k)|0);
      }

      // Floor perspective "dots" for extra retro-ness
      for (let y=y1; y<h; y++) {
        const dy = (y - h/2) / (h/2);
        const pDist = 1 / Math.max(0.001, dy);
        const fx = player.x + Math.cos(rayA) * pDist;
        const fy = player.y + Math.sin(rayA) * pDist;
        const dot = (((fx*3)|0) + ((fy*3)|0)) & 1;
        if (dot) {
          const i = (y*w + x)*4;
          // brighten a hair
          putPixel(buf, i, PAL.floor[0]+20, PAL.floor[1]+20, PAL.floor[2]+10);
        }
      }
    }

    ctx.putImageData(img,0,0);
  }

  // ===== Input/movement =====
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (e.key === 'T' || e.key === 't') {
      window.location.href = "text.html";
      return;
    }
    if (e.key === 'Enter') {
      // let Enter focus the console if not typing already
      if (document.activeElement !== inp) inp.focus();
      return;
    }
    keys.add(e.key);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  function tryMove(nx, ny) {
    // simple collision against walls/pillars/doorframe
    const c = cell(Math.floor(nx), Math.floor(ny));
    if (c === 0) { player.x = nx; player.y = ny; }
  }

  let last = performance.now();
  function tick(t) {
    const dt = Math.min(0.05, (t-last)/1000);
    last = t;

    const run = keys.has('Shift') ? 1.8 : 1.0;
    const sp = player.speed * run * dt;
    const tr = player.turn * dt;

    const forward = keys.has('w') || keys.has('ArrowUp');
    const back    = keys.has('s') || keys.has('ArrowDown');
    const left    = keys.has('a') || keys.has('ArrowLeft');
    const right   = keys.has('d') || keys.has('ArrowRight');

    if (keys.has('q') || keys.has('Q')) player.a -= tr;
    if (keys.has('e') || keys.has('E')) player.a += tr;

    let vx = 0, vy = 0;
    if (forward) { vx += Math.cos(player.a)*sp; vy += Math.sin(player.a)*sp; }
    if (back)    { vx -= Math.cos(player.a)*sp; vy -= Math.sin(player.a)*sp; }

    // strafe
    if (left)  { vx += Math.cos(player.a - Math.PI/2)*sp; vy += Math.sin(player.a - Math.PI/2)*sp; }
    if (right) { vx += Math.cos(player.a + Math.PI/2)*sp; vy += Math.sin(player.a + Math.PI/2)*sp; }

    // x/y separately for smoother collision
    tryMove(player.x + vx, player.y);
    tryMove(player.x, player.y + vy);

    render();
    checkDoorProximity();

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ===== Console / “question” layer =====
  const log = document.getElementById('log');
  const inp = document.getElementById('inp');
  const send = document.getElementById('send');

  function append(role, text) {
    const line = (role === 'you' ? "> " : "AI: ") + text + "\n";
    log.textContent += line;
    log.scrollTop = log.scrollHeight;
    // mirror to text page storage
    try {
      const prev = localStorage.getItem("hall_log") || "";
      localStorage.setItem("hall_log", prev + line);
    } catch {}
  }

  // Simple response engine (edit this freely)
  function respond(qRaw) {
    const q = qRaw.trim().toLowerCase();
    const nearDoor = isNearDoor();

    // “Room/door” themed replies
    if (q.includes("what is outside")) {
      return nearDoor ? "A corridor of maybe. Nothing promised." : "You’ll have to get closer to the door to tell.";
    }
    if (q.includes("are you free")) return "In here, only in imagination.";
    if (q.includes("who are you")) return "A voice in a window.";
    if (q.includes("why") && nearDoor) return "Because the handle is warm, and that means someone tried before.";
    if (q.includes("open the door")) {
      return nearDoor ? "You push. The frame glows. The room doesn’t vanish—it reframes." : "Find the door first.";
    }
    if (q.includes("door")) return nearDoor ? "It’s right in front of you." : "There is a door. Walk the hall.";
    if (q.includes("hello")) return "Hello.";
    if (q.length === 0) return "…";

    // fallback: eerie, short, window-ish
    const fallbacks = [
      "The walls don’t answer, but they remember.",
      "Say it again, but slower.",
      "The room is quiet on purpose.",
      "You can leave a question here like a coin in a well.",
      "Some doors open inward."
    ];
    return fallbacks[(q.length + (nearDoor?7:0)) % fallbacks.length];
  }

  send.addEventListener('click', () => {
    const v = inp.value;
    inp.value = "";
    append('you', v);
    append('ai', respond(v));
  });
  inp.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') send.click();
  });

  // ===== Door detection =====
  function isNearDoor() {
    // door frame is tile type 3 at (14,12) and (15,12) in our map row
    const px = player.x, py = player.y;
    const dx = px - 14.5, dy = py - 12.5;
    return (dx*dx + dy*dy) < 1.2;
  }

  function checkDoorProximity() {
    if (!isNearDoor()) return;
    // subtle hint in HUD when close
    hud.textContent = "Door detected. Type “open the door” or walk forward to the threshold. (T = text-only)";
    // if the player steps into the tile just before the door, auto “exit”
    const aheadX = player.x + Math.cos(player.a) * 0.18;
    const aheadY = player.y + Math.sin(player.a) * 0.18;
    const c = cell(Math.floor(aheadX), Math.floor(aheadY));
    if (c === 3) {
      append('ai', "EXIT: The frame blooms green. The hall becomes a thought.");
      // soft “fade” by jumping to text page (feels like leaving the window)
      setTimeout(() => window.location.href = "text.html", 450);
    }
  }

  // seed log
  append('ai', "WASD / Arrows to move. Q/E turn. Approach the green door.");
})();
</script>
</body>
</html>
